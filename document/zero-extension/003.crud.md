# 木叶鸢：CRUD

> 谁作轻鸢壮远观，似嫌飞鸟未多端。才乘一线凭风去，便有愚儿仰面看。——王令《纸鸢》

* 项目地址：<https://github.com/silentbalanceyh/vertx-zero-example/>（子项目：**upe-ambient**）

项目名：**zero-crud**

|表前缀|业务名|缩略名|主配置|
|---|---|---|---|
|无|crud|Ix|plugin/crud/configuration.json|

日志文件logback.xml：

```xml
    <include resource="plugin/annal/zero-module-crud.xml"/>
```

> 前文有两个章节讲解如何配置Jooq和自动生成Zero中需要的代码，本篇开始不再说明，主要参考《[1.10.珷玞：Jooq](/document/zero/010.jooq.md)》。

## 「壹」CRUD

### 1.1. 功能表

&ensp;&ensp;&ensp;&ensp;我们大多数时间开发的基于RESTful的企业系统都是标准的CRUD系统，该系统中包含了普通的增删查改相关操作，而这些操作于很多系统而言都是没有任何技术含量的，但其业务含量和复杂度却根据需求而有所不同。Zero
Framework中标准化的CRUD的基础层（领域层和数据访问层）是依赖Jooq工具生成，而扩展模块`zero-crud`在提供了快速开发基础CRUD的**功能**：

|功能名称|说明|
|---|:---|
|模板化|根据生成的Dao和Entity两种class执行反射调用，便面重复的CRUD接口开发。|
|标准化|提供CRUD接口的十五个标准化接口，包括增强的CRUD接口。|
|查询引擎|Zero自动提供语法分析、语句分析和性能优化工作，提供复杂条件查询。|
|映射层|连接Zero中的Pojo配置文件，让遗留系统很容易对接到Zero框架中。|
|属性 - 主键|主键属性自动识别和运算，UUID格式。|
|属性 - 序号|「依赖`zero-ambient`」序号属性自动运算，对接`X_NUMBER`中的序号定义生成。|
|属性 - 唯一|提供多维度唯一属性自动计算，每个实体支持多组唯一键、每组跨越多字段。|
|属性 - 责任|责任属性自动辅助，创建/更新（`createdAt, createdBy, updatedAt, updatedBy`）。|
|属性 - 复杂|复杂属性自动计算，`JsonObject`和`JsonArray`格式。|
|`X-`请求头|支持`X-`系列自定义头运算，支持多租户、多语言、多应用功能。|
|列 - 静态|「依赖`zero-ui`」静态计算数据列，关联配置`plugin/ui/column/configuration.json`。|
|列 - 动态|「依赖`zero-ui`」动态计算数据列，最终访问`UI_COLUMN`表。|
|连接模式|自动计算简单常用的`JOIN`连接，支持跨表模型，提供简单CRUD操作。|
|转换|支持数据在导入、导出的整个流程中实现字段级的转换运算。|

&ensp;&ensp;&ensp;&ensp;上述功能是`zero-crud`扩展模块提供的功能支持表，如果您使用了Zero扩展模块，则您就可以不用开发任意的CRUD标准化接口，只是这些功能有一定的限制：

1. 部分功能依赖其他Zero扩展模块如`zero-ambient`或`zero-ui`，但`zero-crud`项目可独立使用，并不和这些模块产生依赖关系。
2. 部分功能依赖前端设置启用和禁用开关，根据适当的配置打开或关闭相关功能点。
3. 部分表结构属性是基于Zero扩展模块设计，所以其字段属性名是固定而不可变更的。

&ensp;&ensp;&ensp;&ensp;**注**：`zero-crud`项目一旦开启，它提供的RESTful定义有可能会导致**开发路径**的冲突，若要使用则请先理解十五个标准化接口以避免URI冲突；其次该项目不会有任何额外表结构，它提供的更多功能是**工具性**的；最后，您项要求的功能越复杂，则配置也会相对复杂。

> 由于配置路径优先级低于开发路径，如果路径发生冲突会以开发路径为主。

### 1.2. 接口标准化

&ensp;&ensp;&ensp;&ensp;`zero-crud`中提供的十五个标准化接口如下，假设实体名称为`pojo`：

|方法|路径|批量|含义以及示例|
|---|:---|---|:---|
|POST|/api/pojo|x|单记录创建|
|GET|/api/pojo/:key|x|根据ID读取记录|
|PUT|/api/pojo/:key|x|根据ID更新记录|
|DELETE|/api/pojo/:key|x|根据ID删除记录|
|POST|/api/pojo/search|o|Qr查询，分页、排序、列过滤、条件综合查询接口|
|PUT|/api/batch/pojo/update|o|批量更新接口|
|DELETE|/api/batch/pojo/delete|o|批量删除接口|
|GET|/api/columns/pojo/full|o|「视图」读取列表中的所有列接口|
|GET|/api/columns/pojo/my|x|「视图」读取角色或用户视图信息|
|PUT|/api/columns/pojo/my|x|「视图」更新用户视图信息|
|POST|/api/pojo/import|o|批量导入数据接口|
|POST|/api/pojo/export|o|批量导出数据接口|
|POST|/api/pojo/existing|x|Qr查询，记录存在true，不存在false|
|POST|/api/pojo/missing|x|Qr查询，记录不存在true，存在false|
|GET|/api/pojo/by/sigma|o|完整记录查询接口，查询某个`sigma`租户旗下所有记录|

&ensp;&ensp;&ensp;&ensp;`zero-crud`中的实际路径匹配表（Vert.x中Router加载的原始路径）如：

|方法|路径|实际路径|
|---|:---|:---|
|POST|/api/pojo|/api/:actor|
|GET|/api/pojo|/api/:actor/:key|
|PUT|/api/pojo|/api/:actor/:key|
|DELETE|/api/pojo|/api/:actor/:key|
|POST|/api/pojo/search|/api/:actor/search|
|PUT|/api/batch/pojo/update|/api/batch/:actor/update|
|DELETE|/api/batch/pojo/delete|/api/batch/:actor/delete|
|GET|/api/columns/pojo/full|/api/columns/:actor/full|
|GET|/api/columns/pojo/my|/api/columns/:actor/my|
|PUT|/api/columns/pojo/my|/api/columns/:actor/my|
|POST|/api/pojo/import|/api/:actor/import|
|POST|/api/pojo/export|/api/:actor/export|
|POST|/api/pojo/existing|/api/:actor/existing|
|POST|/api/pojo/missing|/api/:actor/missing|
|GET|/api/pojo/by/sigma|/api/:actor/by/sigma|

&ensp;&ensp;&ensp;&ensp;如果您不使用`zero-crud`，那么对URI的设计可以随意而为之，但您若使用了该扩展模块，那么您所考虑的路径设计就是避免和上述**实际路径**发生冲突而不是原始路径。例如：`POST /api/user/search`和`POST /api/role/search`在Zero中都会被映射到`POST /api/:actor/search`，底层属于同一个接口，该部分内容在`zero-rbac`鉴权引入时会讲解部分解决方案以实现优良的**路径编排**。您也可以参考下边的指导规则（实战经验，`zero-crud`的限制）

1. 当遇到复杂接口需编写时，可直接使用`POST /api/pojo/xxx`，此处`xxx`为一个动词，如：`POST /api/order/submit`表示提交订单。
2. 上述十五个接口中若您的接口有必要重写，可直接指定路径，如直接重写`GET /api/pojo/:key`，如此，`pojo`这个类的按ID读取记录的方法会被直接重写，并且不会覆盖其他配置上标准化接口。
3. 如果查询方式很多并且复杂，尽可能不设计过多的路径参数，如`/api/user/:status/:name/:type`这种路径就有可能导致很大的副作用，有时候会无意识覆盖您已经开发好的路径。
4. 参数过多的查询，使用`POST`在代码级别去考虑接口幂等性，而不是使用`GET`带上过长的查询参数。

## 「贰」配置详解

&ensp;&ensp;&ensp;&ensp;`zero-crud`的配置文件根据Zero Extension的扩展规范，会放在`plugin/crud/`目录中，该目录为固定目录，它的整理目录结构如下：

```shell
/configuration.json      # 主配置
/module/                 # 模块配置
/validator/              # 验证规则配置
```

&ensp;&ensp;&ensp;&ensp;验证规则配置文件和《[1.5.孤城暗雪：验证](/document/zero/005.validation.md)》中的玩法一样，此处就不累赘，本章节主要讲解该模块中的核心功能配置。

### 1. 主配置

&ensp;&ensp;&ensp;&ensp;主配置位于`configuration.json`中，常用配置如：

```json
{
    "patterns": [
        "/api/{0}",
        "/api/{0}/by/sigma",
        "/api/{0}/:key",
        "/api/batch/{0}/delete",
        "/api/batch/{0}/update",
        "/api/columns/{0}/my",
        "/api/columns/{0}/full",
        "/api/{0}/search",
        "/api/{0}/missing",
        "/api/{0}/existing",
        "/api/{0}/import",
        "/api/{0}/export"
    ],
    "columnKeyField": "dataIndex",
    "columnLabelField": "title"
}
```

&ensp;&ensp;&ensp;&ensp;它包含了三个配置项：

|节点名|类型|含义|
|---|---|:---|
|patterns|JsonArray|标准化接口列表|
|columnKeyField|String|属性字段名|
|columnKeyLabel|String|属性显示字段名|

#### 1.1. 标准化扩展

&ensp;&ensp;&ensp;&ensp;`patterns`主要负责标准化接口的扩展，除了上述十五个**标准化接口**以外，您还可以开发自定义的标准化接口，表达式中的`{0}`等价于标准化接口中的`:actor`参数。自己开发标准化接口的难点在于必须对`zero-crud`中的核心数据结构完全理解并且理解相关流程。

> actor含义为行动者，此处为module含义等价，一方面代表了当前API在执行时模块的名称，另外一方面隐喻了内部算法使用了Actor设计模式。

#### 1.2. 业务属性

&ensp;&ensp;&ensp;&ensp;`columnKeyField`和`columnKeyLabel`配置的是业务属性，如下可看见的列表：

![](_image/2021-10-15-23-45-18.png)

&ensp;&ensp;&ensp;&ensp;由于`zero-ui`使用了基于React的Ant-Design，此处包含了三个属性：**父类型、编码、名称**，这三个属性在后端可能对应：`parentId=父类型,code=编码,name=名称`，如果您的前端无需支持**多语言**结构，这两个配置留空也不会影响前端呈现，这两个配置可以说是为了界面语言**可配置**量身定制的属性。

&ensp;&ensp;&ensp;&ensp;核心功能在于支持标准化接口中的三个「**视图**」接口，整体流程参考下图：

![](_image/2021-10-16-00-07-08.png)

&ensp;&ensp;&ensp;&ensp;从图上可以看到，`zero-crud`中的视图信息主要来自两个模块`zero-ui`和`zero-rbac`，`zero-ui`中包含了整个系统的全部视图列信息，而`zero-rbac`中仅包含了**我的**视图（个人视图）信息，整个视图的层次过滤结构如下图：

![](_image/2021-10-16-00-20-18.png)

> 废话这么多是因为这Zero中的这部分内容和**columnKeyField**和**columnKeyLabel**紧密相关。

&ensp;&ensp;&ensp;&ensp;图中呈现的是Zero中的完整视图结构，解释一下几个定义：

* **可见列**：除开系统不可见（比如开发人员后台代码需要使用）以外所有可访问的列信息。
* **可配列**：这部分控制在Zero Extension中由`zero-ui`实现，比如一个固定列表可能只显示整张表的部分列信息，那么可以在`zero-ui`中使用**动态配置**（存储在数据库中）或**静态配置**（配置文件中定义），只有动态配置的列可直接在平台级管理——如此您可以直接修改您的列表。
* **可控列**：可控列主要包含**角色级**和**用户级**两种，这两种列信息在Zero Extension中由`zero-rbac`实现，角色级的列主要由后台管理员创建、管理和定义，用户级的列就是**个人视图**的一部分。

&ensp;&ensp;&ensp;&ensp;为了实现上述列呈现功能，往往会用到如下数据格式：

```json
[
    {
        "field": "xxx",
        "title": "yyy"
    },
    "..."
]
```

&ensp;&ensp;&ensp;&ensp;上述格式中，`field`表示从后端读取到的数据的记录属性名，`title`则表示从后端读取到的数据对应的**呈现文字**，一般情况下呈现文字并不会包含在您的代码中，这部分如何实现放到`zero-ui`中去讲，而`columnKeyField`和`columnKeyLabel`就是对`field`和`title`的节点名称的配置，如此，您的数据库中存储的属性名和前端呈现用的数据格式部分的属性名就直接解耦（不绑定），所以前端开发可以肆无忌惮、而后端开发就可以随心所欲了，最终链接时依赖这个配置即可。

### 2. 模块配置

&ensp;&ensp;&ensp;&ensp;模块配置是`zero-crud`部分的重点，
